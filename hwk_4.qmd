---
title: "HWK 4"
author: "Emma Bea Mitchell"
format: html
editor_options: 
  chunk_output_type: console
---

red abalone - Haliotis rufescens

#### Load libraries

```{r}
# Load packages
library(tidyverse)
library(here)
library(tmap)
library(stars)
library(terra)
library(sf)
library(raster)
```

#### Read in data

```{r}
# Read in data
wc_eez <- st_read(here("data", "data", 'wc_regions_clean.shp'))
temp_2008 <- rast(here("data", "data", "average_annual_sst_2008.tif"))
temp_2009 <- rast(here("data", "data", "average_annual_sst_2009.tif"))
temp_2010 <- rast(here("data", "data", "average_annual_sst_2010.tif"))
temp_2011 <- rast(here("data", "data", "average_annual_sst_2011.tif"))
temp_2012 <- rast(here("data", "data", "average_annual_sst_2012.tif"))
depth <- rast(here("data", "data", "depth.tif"))
```

## Process data

```{r}
# combine temp rasters into stack
sst_stack <- c(temp_2008, temp_2009, temp_2010, temp_2011, temp_2012)
```


```{r}
# Check if crs match
# make into function or for loop
st_crs(sst_stack) == st_crs(depth)
st_crs(depth) == st_crs(wc_eez)
st_crs(sst_stack) == st_crs(wc_eez)

sst_stack_recrs <- project(sst_stack, crs(depth))

```


```{r}
# Find average SST
mean_sst <- app(sst_stack_recrs, mean, na.rm = TRUE)

# Convert average SST from Kelvin to Celsius
mean_sst_c <- mean_sst - 273.15

```


```{r}
# Crop depth raster to match the extent of the SST raster

depth_crop <- crop(depth, mean_sst_c)

# Resample the depth data to match the resolution of the SST data using the nearest neighbor approach

depth_resample <- resample(depth_crop, mean_sst_c, method = "near")

# check that the depth and SST match in resolution, extent, and coordinate reference system
# make this into if else statement?

sst_depth <- c(depth_resample, mean_sst_c)

```

## Find suitable locations

oysters:
sea surface temperature: 11-30°C
depth: 0-70 meters below sea level

red abalone: 
sea surface temperature: 8°C - 18°C 
depth: 0-24 meters below sea level

```{r}
# Define the suitable SST range
oyster_sst <- ifel(mean_sst_c >= 11 & mean_sst_c <= 30, 1, 0)

# Define the suitable depth range
oyster_depth <- ifel(depth_resample >= 0 & depth_resample <= 70, 1, 0)

# make function 
oyster_fun <- function(oyster_depth, oyster_sst){
 oyster_locations <- ifel(oyster_sst == 1 & oyster_depth == 1, 1, 0)
  return(oyster_locations)
}  

oyster_locations <- oyster_fun(oyster_depth, oyster_sst)

plot(oyster_locations)


```

## Determine the most suitable EEZ

```{r}
# cropping suitable oyster locations to the eezs 

# rasterize eez data
wc_eez_rast <- rasterize(wc_eez, oyster_locations, "rgn")


# Crop oyster_locations to the extent of wc_eez_rast
cropped_oyster_locations <- crop(oyster_locations, wc_eez_rast)

# Mask the cropped oyster_locations with wc_eez_rast
oyster_eez <- mask(cropped_oyster_locations, wc_eez_rast)

# Plot the result
plot(oyster_eez, main = "Intersected Oyster Locations with EEZ")


```


```{r}
# group by eez, write function to find suitable locations in each eez 


# Step 1: Convert SpatRaster objects to data frames
oyster_eez_df <- as.data.frame(oyster_eez, xy = TRUE) |>
    mutate(suitable = mean == 1)
wc_eez_df <- as.data.frame(wc_eez_rast, xy = TRUE)

# Merge the data frames based on coordinates
merged_df <- merge(oyster_eez_df, wc_eez_df, by = c("x", "y"))

# Step 2: Group and summarize
# Assuming 'rgn' is a column in the merged data frame and 'suitable' is a column indicating suitability
locations_by_eez <- merged_df %>%
  group_by(rgn) %>%
  summarise(oyster_locals = sum(suitable == 1, na.rm = TRUE)) |>
  arrange(desc(oyster_locals), .by_group=TRUE)

print(locations_by_eez)

# probably want to replot this to show suitable locations and eezs (turn back into raster? or vector)
```

## Make a function

```{r}
# now make it into a function???





```

